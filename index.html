<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cards: per-length font instance selection</title>

  <style>
    :root{
      --cardW: 9cm;
      --gap: 10px;
      --stroke: 1px solid #000;
      --pad: 0;
    }

    body{ margin:16px; background:#fff; color:#000; font-family: system-ui, sans-serif; }
    #deck{ display:flex; flex-wrap:wrap; gap:var(--gap); align-items:flex-start; }

    .card{
      width: var(--cardW);
      aspect-ratio: 9 / 3;
      border: var(--stroke);
      border-radius: 0;
      box-sizing: border-box;
      padding: var(--pad);
      overflow: hidden;
    }
    .card svg{ width:100%; height:100%; display:block; }
    .card path{ fill:#000; }

    @media print{
      body{ margin:0; }
      #deck{ gap:6mm; }
      .card{ break-inside: avoid; }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="words.js"></script>
</head>

<body>
  <div id="deck"></div>

  <script>
    if (typeof words === "undefined" || !Array.isArray(words)) {
      throw new Error("words.js must define: const words = [ ... ];");
    }

    // ============================================================
    // 1) FREE MAP OF STATIC FONT INSTANCES (key -> path)
    // ============================================================
    const FONT_FILES = {
      "w1": "./fonts/Merriweather/static/Merriweather_24pt_SemiCondensed-Medium.ttf",
      "w2": "./fonts/Merriweather/static/Merriweather_24pt-Light.ttf",
      "w3": "./fonts/Merriweather/static/Merriweather_24pt-Medium.ttf",
      "light24c": "./fonts/Merriweather/static/Merriweather_24pt_SemiCondensed-Light.ttf",
      "light24": "./fonts/Merriweather/static/Merriweather_24pt-Light.ttf",
      "extrabold24c": "./fonts/Merriweather/static/Merriweather_24pt_SemiCondensed-ExtraBold.ttf",
      "extrabold24": "./fonts/Merriweather/static/Merriweather_24pt-ExtraBold.ttf",
      "light120c": "./fonts/Merriweather/static/Merriweather_120pt_SemiCondensed-Light.ttf",
      "extrabold120c": "./fonts/Merriweather/static/Merriweather_120pt_SemiCondensed-ExtraBold.ttf",
      "extrabold120": "./fonts/Merriweather/static/Merriweather_120pt-ExtraBold.ttf",

    };

    // Load every font in the map up-front.
    // (If this is too heavy later, you can prune the map or lazy-load, but you asked for preload.)
    const fonts = {};         // key -> opentype.Font
    const fitters = {};       // key -> fitWord function

    async function loadAllFonts() {
      const entries = Object.entries(FONT_FILES);
      for (const [key, url] of entries) {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Font fetch failed: ${res.status} ${url}`);
        const buf = await res.arrayBuffer();
        fonts[key] = opentype.parse(buf);
      }
    }

    // ============================================================
    // 2) Rendering model: SVG paths, full-width fit, constant-height scale,
    //    x-height baseline centering. (Same as your working approach.)
    // ============================================================
    const VIEW_W = 300;
    const VIEW_H = 100;

    const VB_PAD_X = 6;
    const VB_PAD_Y = 6;

    const FONT_SIZE = 1000;

    // Height reference: defines the “as if has f and p” scale.
    // Keep what worked for you; you can tune it later.
    const HEIGHT_REF = "?g";

    // Tracking is intentionally controlled ONLY in the if/else chain (below).
    // This global default is just a fallback.
    const DEFAULT_TRACKING_EM = 0.00;

    const deck = document.getElementById("deck");

    function svgEl(name){
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function clearDeck(){
      while (deck.firstChild) deck.removeChild(deck.firstChild);
    }

    function getXHeightInPathUnits(font){
      const scale = FONT_SIZE / font.unitsPerEm;
      const os2 = font.tables && font.tables.os2;
      if (os2 && typeof os2.sxHeight === "number" && os2.sxHeight > 0) {
        return os2.sxHeight * scale;
      }
      const gx = font.charToGlyph("x").getPath(0, 0, FONT_SIZE);
      const bb = gx.getBoundingBox();
      const yTop = Math.min(bb.y1, bb.y2);
      return Math.max(1, -yTop);
    }

    function buildWordPathHorizontal(font, word, trackingEm){
      const scale = FONT_SIZE / font.unitsPerEm;
      const trackingPx = trackingEm * FONT_SIZE;

      const p = new opentype.Path();
      let x = 0;
      let prev = null;

      for (let i = 0; i < word.length; i++){
        const glyph = font.charToGlyph(word[i]);

        if (prev){
          x += font.getKerningValue(prev, glyph) * scale;
          x += trackingPx; // tracking here
        }

        p.extend(glyph.getPath(x, 0, FONT_SIZE));

        const adv = (glyph.advanceWidth || font.unitsPerEm) * scale;
        x += adv;
        prev = glyph;
      }

      return { path: p, xStart: 0, xEnd: x };
    }

    function makeFitter(font, trackingEmForRef){
      const targetW = VIEW_W - 2 * VB_PAD_X;
      const targetH = VIEW_H - 2 * VB_PAD_Y;

      // constant vertical scale from ref string
      const ref = buildWordPathHorizontal(font, HEIGHT_REF, trackingEmForRef);
      const refBB = ref.path.getBoundingBox();
      const refTop = Math.min(refBB.y1, refBB.y2);
      const refBot = Math.max(refBB.y1, refBB.y2);
      const refH = (refBot - refTop) || 1;

      const sy = targetH / refH;

      // baseline chosen so x-height center sits at card center
      const xHeight = getXHeightInPathUnits(font);
      const baselineY = (VB_PAD_Y + targetH / 2) + sy * (xHeight / 2);

      return function fitWord(out){
        const { path, xStart, xEnd } = out;
        const bb = path.getBoundingBox();

        let left = xStart, right = xEnd;
        if (bb.x1 < left) left = bb.x1;
        if (bb.x2 > right) right = bb.x2;

        const bw = (right - left) || 1;
        const sx = targetW / bw;

        const midX = (left + right) / 2;
        const tx = (VB_PAD_X + targetW / 2) - midX * sx;

        const ty = baselineY;

        return {
          d: path.toPathData(2),
          transform: `translate(${tx.toFixed(3)} ${ty.toFixed(3)}) scale(${sx.toFixed(6)} ${sy.toFixed(6)})`
        };
      };
    }

    function buildCard(font, word, trackingEm, fitWord){
      const card = document.createElement("div");
      card.className = "card";

      const svg = svgEl("svg");
      svg.setAttribute("viewBox", `0 0 ${VIEW_W} ${VIEW_H}`);
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      const out = buildWordPathHorizontal(font, word, trackingEm);
      const fitted = fitWord(out);

      const g = svgEl("g");
      g.setAttribute("transform", fitted.transform);

      const path = svgEl("path");
      path.setAttribute("d", fitted.d);

      g.appendChild(path);
      svg.appendChild(g);
      card.appendChild(svg);
      return card;
    }

    // ============================================================
    // 3) ONE SINGLE PLACE TO TUNE: if/else chain
    //    You adjust only this block to test visually.
    // ============================================================
    function chooseStyle(rawWord) {
      const len = rawWord.length;

      // Default outputs:
      let fontKey = "extrabold120c";
      let trackingEm = DEFAULT_TRACKING_EM;
      let padLeft = 1;   // number of regular spaces to add
      let padRight = 1;

      // ---- ONLY EDIT BELOW THIS LINE ----
      if (false) {

      }
      else if (len <= 1) {
        fontKey = "w1";
        padLeft = 2; padRight = 2;
      }
      else if (len <= 2) {
        fontKey = "w2";
        trackingEm = -0.006;
        padLeft = 1; padRight = 1;
      } 
        else if (len <= 3) {
        fontKey = "w3";
        trackingEm = 0.000;
        padLeft = 1; padRight = 1;
      } else if (len <= 4) {
        fontKey = "extrabold24c";
        trackingEm = 0.002;
        padLeft = 1; padRight = 1;
      } else {
        fontKey = "extrabold120";
        trackingEm = 0.004;    // more air for long words
        padLeft = 0; padRight = 0;
      }
      // ---- ONLY EDIT ABOVE THIS LINE ----

      const word = " ".repeat(padLeft) + rawWord + " ".repeat(padRight);
      return { fontKey, trackingEm, word };
    }

    // ============================================================
    // 4) Render (preload everything, then build)
    // ============================================================
    async function main(){
      await loadAllFonts();

      // Build fitters per fontKey, using that fontKey’s current ref-tracking.
      // Since tracking is chosen per word, we create fitters lazily per (fontKey, trackingEm).
      // To keep logic centralized, we cache by a combined key.
      const fitterByKey = {}; // `${fontKey}|${trackingEm}` -> function

      clearDeck();

      for (const raw of words){
        const { fontKey, trackingEm, word } = chooseStyle(raw);

        const font = fonts[fontKey];
        if (!font) throw new Error(`Missing fontKey in FONT_FILES: ${fontKey}`);

        const fk = `${fontKey}|${trackingEm}`;
        if (!fitterByKey[fk]) {
          fitterByKey[fk] = makeFitter(font, trackingEm);
        }

        deck.appendChild(buildCard(font, word, trackingEm, fitterByKey[fk]));
      }
    }

    main().catch(console.error);
  </script>
</body>
</html>
