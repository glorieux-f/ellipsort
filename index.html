<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Glyph-box vertical cards</title>

  <style>
    :root{
      --cardW: 140px;
      --gap: 14px;
      --radius: 14px;
      --border: 1px solid #999;
      --fg: #111;
      --bg: #fff;
    }

    body{ font-family: system-ui, sans-serif; margin: 16px; background: #fafafa; }
    .controls{ display:flex; gap:12px; align-items:center; margin-bottom: 14px; }
    .hint{ font-size: 12px; color:#444; }

    #deck{
      display:flex;
      gap: var(--gap);
      flex-wrap: wrap;
      align-items: flex-start;
    }

    .card{
      width: var(--cardW);
      height: 9cm;
      width: 3cm;
      border: var(--border);
      padding: 0 1rem;
      overflow:hidden;
      background: var(--bg);
    }

    .card svg{ width:100%; height:100%; display:block; }
    .card path{ fill: var(--fg); }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
    <script src="ellipsort.js"></script>
</head>

<body>
  <div class="controls">
    <label>
      Font file (TTF/OTF):
      <input id="fontFile" type="file" accept=".ttf,.otf" />
    </label>
    <span class="hint">Optional: place <code>font.ttf</code> next to this HTML to auto-load.</span>
  </div>

  <div id="deck"></div>

  <script>

    // --- Geometry in SVG user units (fixed for all cards) ---
    const VIEW_W = 100;
    const VIEW_H = 300;

    // Constant vertical gap between letter boxes (same for every word)
    const GAP = 8;          // increase/decrease to control spacing
    const PAD_Y = 10;       // top/bottom padding in view units
    const INSET = 0.98;     // <1 leaves margin inside each letter box; set 1 for edge-to-edge

    // opentype working font size (arbitrary but consistent)
    const FONT_SIZE = 1000;

    const deck = document.getElementById("deck");
    const fontInput = document.getElementById("fontFile");

    function svgEl(name){
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }

    function clearDeck(){
      while (deck.firstChild) deck.removeChild(deck.firstChild);
    }

    function buildCard(font, word){
      const card = document.createElement("div");
      card.className = "card";

      const svg = svgEl("svg");
      svg.setAttribute("viewBox", `0 0 ${VIEW_W} ${VIEW_H}`);
      // viewBox matches card aspect ratio (1:3), so "meet" is fine; "none" also works.
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      const L = word.length;
      const usableH = VIEW_H - 2 * PAD_Y - (L - 1) * GAP;
      const boxH = usableH / L;
      const boxW = VIEW_W;

      if (boxH <= 0) {
        console.warn("Not enough height for word:", word);
        return card;
      }

      for (let i = 0; i < L; i++){
        const ch = word[i];

        // Get glyph outline at origin
        const gp = font.getPath(ch, 0, 0, FONT_SIZE);
        const bb = gp.getBoundingBox();
        const gw = bb.x2 - bb.x1;
        const gh = bb.y2 - bb.y1;

        // Skip empty glyphs safely
        if (gw <= 0 || gh <= 0) continue;

        // Letter box top-left
        const x0 = 0;
        const y0 = PAD_Y + i * (boxH + GAP);

        // Scale glyph to (boxW, boxH), with optional inset
        const targetW = boxW * INSET;
        const targetH = boxH * INSET;
        const sx = targetW / gw;
        const sy = targetH / gh;

        // Center glyph inside its letter box
        const scaledW = gw * sx;
        const scaledH = gh * sy;
        const tx = x0 + (boxW - scaledW) / 2 - bb.x1 * sx;
        const ty = y0 + (boxH - scaledH) / 2 - bb.y1 * sy;

        const g = svgEl("g");
        g.setAttribute("transform", `translate(${tx} ${ty}) scale(${sx} ${sy})`);

        const path = svgEl("path");
        path.setAttribute("d", gp.toPathData(2));

        g.appendChild(path);
        svg.appendChild(g);
      }

      card.appendChild(svg);
      return card;
    }

    function render(font){
      clearDeck();
      for (const w of ellipsort){
        deck.appendChild(buildCard(font, w));
      }
    }

    async function loadFontFromFile(file){
      const buf = await file.arrayBuffer();
      return opentype.parse(buf);
    }

    async function loadFontFromUrl(url){
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Font fetch failed: ${res.status}`);
      const buf = await res.arrayBuffer();
      return opentype.parse(buf);
    }

    // Optional auto-load ./font.ttf
    (async () => {
      try{
        const font = await loadFontFromUrl("./font.ttf");
        render(font);
      } catch {
        // ignore: user can choose a font file
      }
    })();

    fontInput.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const font = await loadFontFromFile(file);
      render(font);
    });
  </script>
</body>
</html>
